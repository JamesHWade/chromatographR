---
title: "chromatographR"
author: "Ethan Bass"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{chromatographR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library("knitr", quietly=TRUE)
library(chromatographR)
library(parallel)
opts_chunk$set(prompt = TRUE, highlight = FALSE, comment=NA, 
               fig.width=6)
suppressMessages(require(chromatographR, quiet=TRUE))
```

## Introduction
*chromatographR* is a package for the reproducible analysis of HPLC-DAD data in `R`. Liquid chromatography coupled to diode-array detection (HPLC-DAD) remains one of the most popular analytical methodologies due to its convenience and low-cost. However, there are currently very few open-source tools available for analyzing HPLC-DAD chromatograms. The use of proprietary software for the analysis of HPLC-DAD data is currently a significant barrier to reproducible science, since these tools are not widely accessible, but usually involve the user to select complicated options through a graphical interface which aren't easily repeatable. Reproducibility is much higher in command line workflows, like *chromatographR*, where the entire analysis can be stored and easily repeated by anyone using publicly available software.

The *chromatographR* package draws inspiration from the previously published *alsace* package [@wehrens2015], but with improved functions for peak-finding, integration and peak table generation as well as a number of new tools for data visualization and downstream analysis. Unlike *alsace*, which emphasized multivariate curve resolution through alternating least squares (MCR-ALS), *chromatographR* is developed around a more conventional workflow that will probably seem more familiar to users of standard software tools for HPLC-DAD analysis. *chromatographR* includes tools for a) pre-processing, b) retention-time alignment, c) peak-finding, d) peak-integration and e) peak-table construction, as well as additional functions useful in analysis of the resulting peak table.

## Workflow
### Loading data

chromatographR now includes an option to directly convert files from ChemStation or MassHunter. Alternatively, the data from the spectrometer can be converted into an `R`-friendly  format like a `csv` file. The `load_chroms` function provides a simple interface to read chromatograms into `R` from any of these formats.

```{r,eval=F}
# single folder
load_chroms(paths = path, format.in="csv")

# multiple folders
path = 'foo'
folders <- list.files(path = path, pattern = "EXPORT3D")
dat <- load_chroms(folders)
```

### Example data
We have included some example data consisting of root extracts from tall goldenrod (*Solidago altissima*).

```{r, data}
data(Sa)
```

### Pre-processing data

Data from liquid chromatography often suffer from a variety of non-informative artifacts, such as noise or a drifting baseline. In addition, the data produced by the instrument may have a higher resolution or wider range (along either the time or spectral dimensions) than we require. Fortunately, most of these issues can be remedied fairly easily. For example, smoothing can reduce noise in the spectral direction while baseline subtraction can help correct a drifting baseline. Interpolation of wavelengths and retention times can be used to reduce the dimensionality of the data, facilitating comparison across samples and reducing the time and computational load required by downstream analyses. All of these functions (smoothing, baseline correction, and interpolation) are available through the `preprocess` function and are enabled by default.

To select a narrower range of times and/or wavelengths, arguments can be provided to `dim1` and `dim2` arguments. The `baseline_cor` function from the *ptw* package [@bloemberg2010] takes arguments `p` (an asymmetry parameter) and `lambda` (a smoothing parameter). You can read more about these in the documentation for `ptw::asysm`.  You may want to experiment with these parameters before choosing values to use on your whole dataset.

```{r, choosing parameters}
i=2 # chromatogram number in list of data
tpoints <- as.numeric(rownames(Sa[[i]]))
lambda='200.00000'

matplot(x=tpoints, y=Sa[[i]][,lambda],
       type='l', ylab='Abs (mAU)', xlab='Time (min)')
matplot(x=tpoints, y = ptw::baseline.corr(Sa[[i]][,lambda],p=.001,lambda=1e5),
       type='l', add = T, col='blue', lty = 3)
```

```{r, choosing dimensions}
new.ts <- seq(10,18.66,by=.01) # choose time-points
new.lambdas <- seq(200, 318, by = 2) # choose wavelengths
```

```{r, preprocessing, eval=T}
dat.pr <- preprocess(Sa, dim1=new.ts, dim2=new.lambdas,
           parallel=F, p=.001, lambda=1e5)
```

### Dealing with retention time shifts

In many cases, HPLC data can suffer from retention time shifts (e.g. due to temperature fluctuations, column degradation, or subtle changes in mobile-phase composition). Parametric time warping (as implemented in the [ptw](https://cran.r-project.org/web/packages/ptw/index.html) package can be quite an effective technique for correcting subtle retention time shifts [@eilers2004]. If your chromatograms are already perfectly aligned you can skip this step. If you have severe retention time shifts this technique may not be so effective (and you should consider checking your HPLC for leaks). 

The `correct_rt` function is a wrapper around the `ptw` function. For each chromatogram, it produces a "global" warping function across all wavelengths included in `lambdas`). The goal of the warping function is to produce a better alignment of retention times by "warping" the time-axis of each chromatogram to match a reference chromatogram. (The reference chromatogram can be determined algorithmically or selected manually by setting the `reference` argument). The code block below creates warping models for the samples in the provided list of data matrices. The same function is then used to warp each chromatogram according to the corresponding model, by setting the `models` parameter. Depending on the variety of your samples and the severity of the retention time shifts, it may take some experimentation with the warping parameters to get satisfactory results. Sometimes "less" can actually be "more" here -- for example, wavelengths with fewer peaks may sometimes yield better warping models. (Also see the documentation for [ptw](https://cran.r-project.org/web/packages/ptw/index.html) for more ideas about warp function optimization).


```{r, warp model}
warping.models <- correct_rt(dat.pr, what = "models", lambdas=c("210"))
warp <- correct_rt(chrom_list=dat.pr, models=warping.models)
```

You can see that, in this case, the alignment is considerably improved after warping. You can also use the `correct_rt` function to do a global alignment on multiple wavelengths, but this will not always improve the results. While the alignment still isn't perfect after warping, it is probably good enough to align our peaks and assemble them in the peak table, which is our primary goal.

```{r, alignment_plot, fig.height=6}
par(mfrow=c(2,1))
lambdas=c('210','260')
plot.new()
plot.window(xlim=c(head(new.ts,1), tail(new.ts,1)),ylim=c(0,1000))
for (i in 1:length(warp)){
  matplot(new.ts, warp[[i]][,lambdas],type='l',add=T)
}
legend("topright", legend="warped", bty = "n")

plot.new()
plot.window(xlim=c(head(new.ts,1),tail(new.ts,1)),ylim=c(0,1000))
for (i in 1:length(dat.pr)){
  matplot(new.ts, dat.pr[[i]][,lambdas],type='l',add=T)
}
legend("topright", legend="raw", bty = "n")
```

### Peak finding and fitting

The `get_peaks` function loops through your chromatograms at the specified wavelengths, finds peaks, and attempts to fit them to the specified function using non-linear least squares -- the current options are `gaussian` and `egh` (exponential-gaussian hybrid) [@lan2001]. The area under the curve for each peak is then estimated using a trapezoidal approximation method. The function returns a nested list of data.frames containing parameters for the peaks in each chromatogram.

```{r, get_peaks, message=F, warning=F}
pks_gauss <- get_peaks(warp, lambdas = c('210','260'), sd.max=40, fit="gaussian")
pks_egh <- get_peaks(warp, lambdas = c('210', '260'), sd.max=40, fit="egh")
```

The `plot.peak_list` function allows you to visually assess the peak integration accuracy. Below we compare the peaks fitted for the first chromatogram (`index=1`) using the two algorithms. Usually the egh function performs slightly better for asymmetrical peaks.

```{r, plot_peaks, warning=F, fig.height=6}
par(mfrow=c(2,1))
plot(pks_gauss, index=1, lambda='210')
plot(pks_egh, index=1, lambda='210')
```

```{r, get_peaktable}
pk_tab <- get_peaktable(pks_egh, response = "area")
head(pk_tab$tab[,1:6])
```

### Further analysis and data-visualization

##### Attaching meta-data

To begin analyzing your peak table, you will usually want to attach sample meta-data to the `peak_table` object. This can be easily accomplished using the `attach_metadata` function. The peak table can then be normalized (e.g. by dividing out the sample weight) using the `normalize_data` function.

```{r}
path <- system.file("extdata", "Sa_metadata.csv", package = "chromatographR")
meta <- read.csv(path)
pk_tab <- attach_metadata(peak_table = pk_tab, metadata = meta, column="vial")
pk_tab <- normalize_data(peak_table = pk_tab, column="mass")
```

##### Plotting

The `mirror_plot` function provides a quick way to visually compare results across treatment groups.

```{r}
mirror_plot(pk_tab, lambdas = c("210","260"), var = "trt", legend_size=3)
```

The `plot_spectrum` function allows you to easily plot or record the spectra associated with a particular peak in your peak table. This is useful for interpreting your results and/or checking for errors in your peak table. For example, you may want to check if the spectra for a particular peak match across different samples, or you may want to compare your spectrum with a known standard. The `plot_spectrum` function can be used to plot only the spectrum or only the chromatographic trace using the arguments `plot_spectrum` and `plot_trace`. By default it will plot the trace and spectrum from the chromatogram with the largest peak in the peak table. Alternatively, you can choose the chromatogram index and wavelength using the `chr` and `lambda` arguments.

```{r, plot spectra,fig.height=6}
par(mfrow=c(2,1))
peak="V7"
plot_spectrum(peak, peak_table = pk_tab, chrom_list=warp)
```

The `plot_all_spectra` function can be used to visually compare the spectra for a specified peak across all samples.

```{r, plot_all}
peak="V13"
plot_all_spectra(peak, peak_table=pk_tab, export=F, overlapping=T)
```

The plot `peak_table` function provides a simplified interface to various options for plotting data from the peak table. For example, it can be used as a quick interface to the \code{plot_spectrum} and \code{plot_all_spectra} functions shown above. It can also be used to make a quick box plot to compare results across treatments.

```{r,eval=T}
plot(pk_tab, loc = "V9", box_plot = TRUE, vars = "trt")
plot(pk_tab, loc = "V13", box_plot = TRUE, vars = "trt")
```


## References

<div id="refs"></div>

## Session Information

```{r}
sessionInfo()
```